(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{WUDI:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return l})),n.d(t,"default",(function(){return h}));var o=n("Fcif"),a=n("+I+c"),r=(n("mXGw"),n("/FXl")),i=n("TjRS"),s=n("ZFoC"),c=n("RGlQ"),l=(n("aD51"),{});void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/articles/testing/2-pfcs-for-ui-sanity/index.mdx"}});var p={_frontmatter:l},b=i.a;function h(e){var t,n=e.components,h=Object(a.a)(e,["components"]);return Object(r.b)(b,Object(o.a)({},p,h,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"pure-function-components-for-ui-sanity"},"Pure Function Components for UI Sanity"),Object(r.b)("p",null,"The greatest strength of React is the ability of using Pure Functional Components."),Object(r.b)("p",null,"To understand PFCs, let's first understand Pure Functions. A pure function is a function that, given the same parameters, always returns the same result. The results don't depend on anything but its parameters and it does not only interact with the outside world in any other way different ."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-typescript"},"const timesTwo = (value: number) => value * 2;\ntimesTwo(2); // 4\n")),Object(r.b)("p",null,"It doesn't matter how many times you call ",Object(r.b)("inlineCode",{parentName:"p"},"timesTwo"),". As long as the input is ",Object(r.b)("inlineCode",{parentName:"p"},"2"),", the output will always be ",Object(r.b)("inlineCode",{parentName:"p"},"4"),"."),Object(r.b)("p",null,'In React, Pure Functional Components (from now on just "PFCs") are components that simply take the props passed down to them and render the UI state based on them. That\'s precisely what React is all about.'),Object(r.b)("p",null,"Below we have a test Component, ",Object(r.b)("inlineCode",{parentName:"p"},"TrafficLights"),", with a very simple set of props and the expected behavior of any traffic light"),Object(r.b)("h3",{id:"trafficlights---component-props"},"TrafficLights - Component Props"),Object(r.b)(s.c,{of:c.a,mdxType:"Props"}),Object(r.b)("h3",{id:"usage"},"Usage"),Object(r.b)("p",null,"Try changing the ",Object(r.b)("inlineCode",{parentName:"p"},"current"),' prop below from "red" to "yellow" or "green"'),Object(r.b)(s.b,{__position:1,__code:'<TrafficLights current="red" />',__scope:(t={props:h,DefaultLayout:i.a,Playground:s.b,Props:s.c,TrafficLights:c.a},t.DefaultLayout=i.a,t._frontmatter=l,t),mdxType:"Playground"},Object(r.b)(c.a,{current:"red",mdxType:"TrafficLights"})),Object(r.b)("p",null,"Now check the simplified implementation:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-typescript"},'export const TrafficLights = ({ current }: TrafficLightsProps) => (\n  <div>\n    <TrafficLamp color="red" current={current} />\n    <TrafficLamp color="yellow" current={current} />\n    <TrafficLamp color="green" current={current} />\n  </div>\n);\n\nexport const TrafficLamp = ({ color, current }: TrafficLampProps) => (\n  <div\n    style={{\n      backgroundColor: color,\n      opacity: current === color ? 1 : 0.2,\n      width: "30px",\n      height: "30px",\n      borderRadius: "15px",\n      marginBottom: "2px",\n    }}\n  />\n);\n')),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"TrafficLights")," and ",Object(r.b)("inlineCode",{parentName:"p"},"TrafficLamp")," are both PFCs. The most noticeable thing about them is that they do not own their own state nor they use any kind of hook. They can use all the conditional rendering they want, but they don't get to use anything but the props passed down to them."),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"NOTE:\nDo not confuse PFCs with React's Memoized components (a.k.a. PureComponents). Those concepts are somewhat similar, but aren't the same thing (nor are they strictly necessary)")),Object(r.b)("p",null,"The benefit here is that when a component is a PFC, every sigle discrete combination of props leads to a discrete rendered UI state in the output. As no interactions happen inside this component, there's no interaction to test inside of it."),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("strong",{parentName:"p"},Object(r.b)("em",{parentName:"strong"},"OMG!!! Are you saying components don't need Unit Tests? That's HERESY!!!")))),Object(r.b)("p",null,"For the most part, yes, that's precisely what I'm stating. And I go further:"),Object(r.b)("h2",{id:"ui-testing-is-for-humans-not-machines"},"UI Testing is for Humans, not machines"),Object(r.b)("p",null,"Join me for a quick thought experiment. Let's take the component above, the ",Object(r.b)("inlineCode",{parentName:"p"},"TrafficLights")," component. Let's say we write tests for it and everything passes. Now imagine that when we reach QA, they ask us to swap the yellow color for orange as it's more clearly visible. If we're gonna be purists, now we're going to have to write tests checking if the color shown when we pass ",Object(r.b)("inlineCode",{parentName:"p"},"yellow")," is the right shade of orange, as asked by the product team. Going further, why not write tests to check if the lights are actually circles? Whatever we do, there's always the possibility of having a complete set of painfully written tests that do pass, but still won't reflect correctness nor give you Peace of Mind."),Object(r.b)("blockquote",null,Object(r.b)("h3",{parentName:"blockquote",id:"aim-for-confidence"},"AIM FOR CONFIDENCE."),Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("em",{parentName:"p"},'"Test the things that will help you feel confident about your code. It’s easy to fall into the trap of testing everything that is testable, but that’s a rabbit hole you want to avoid. Instead, focus on testing the behaviors on which other parts of your code will rely."')," (taken from these ",Object(r.b)("a",{parentName:"p",href:"https://chromatichq.com/blog/principles-testdriven-development"},"Principles of Test driven Develpment"),")")),Object(r.b)("p",null,"Writing automated tests for checking if a UI totally works is hard. Not only hard, but mostly pointless, as it's just dupplicated work that a human will have to do aftwerwards anyway. And now we introduce a second layer of possible coding mistakes and an additional opportunity for requirement miscomunication. Then Why bothering?"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("em",{parentName:"p"},'"HELL YEAH!!! ANARCHY!!! TESTS ARE A POINTLESS WASTE OF TIME!"'))),Object(r.b)("p",null,"Hold your horses there, ",Object(r.b)("strong",{parentName:"p"},"THAT'S NOT")," what I'm saying. We're not forfeiting testing the UI, we're just leaving testing UI for correctness to who will must do it anyway. When you do it, you unlock one of the greatest advantages of modern React:"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("a",{parentName:"strong",href:"/testing/parallel-ui-qa-with-storybook"},"Parallel UI QA with Storybook"))))}void 0!==h&&h&&h===Object(h)&&Object.isExtensible(h)&&!h.hasOwnProperty("__filemeta")&&Object.defineProperty(h,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/articles/testing/2-pfcs-for-ui-sanity/index.mdx"}}),h.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-articles-testing-2-pfcs-for-ui-sanity-index-mdx-eeaffc4d35315ced6080.js.map