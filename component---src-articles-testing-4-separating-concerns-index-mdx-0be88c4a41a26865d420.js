(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{"5mwW":function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return b})),n.d(t,"default",(function(){return h}));var o=n("Fcif"),r=n("+I+c"),a=n("mXGw"),s=n("/FXl"),c=n("TjRS"),i=n("ZFoC"),l=n("ykuN"),u=n("pUs5"),b=(n("aD51"),{});void 0!==b&&b&&b===Object(b)&&Object.isExtensible(b)&&!b.hasOwnProperty("__filemeta")&&Object.defineProperty(b,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/articles/testing/4-separating-concerns/index.mdx"}});var p={_frontmatter:b},m=c.a;function h(e){var t,n,h=e.components,d=Object(r.a)(e,["components"]);return Object(s.b)(m,Object(o.a)({},p,d,{components:h,mdxType:"MDXLayout"}),Object(s.b)("h1",{id:"separating-concerns-hooks-to-the-rescue"},"Separating Concerns: Hooks to the Rescue"),Object(s.b)("p",null,"First of all, let's take a second and revisit the ",Object(s.b)("inlineCode",{parentName:"p"},"Counter")," component in our very first example"),Object(s.b)(i.b,{__position:0,__code:"() => {\n  const [counter, setCounter] = useState(0)\n  const increase = () => setCounter(counter => counter + 1)\n  const decrease = () => setCounter(counter => counter - 1)\n  return (\n    <div>\n      <button onClick={decrease}>-</button>\n      <span>{counter}</span>\n      <button onClick={increase}>+</button>\n    </div>\n  )\n}",__scope:(t={props:d,DefaultLayout:c.a,useState:a.useState,Playground:i.b,CounterUI:l.a,useCounterController:u.a},t.DefaultLayout=c.a,t._frontmatter=b,t),mdxType:"Playground"},(function(){var e=Object(a.useState)(0),t=e[0],n=e[1];return Object(s.b)("div",null,Object(s.b)("button",{onClick:function(){return n((function(e){return e-1}))}},"-"),Object(s.b)("span",null,t),Object(s.b)("button",{onClick:function(){return n((function(e){return e+1}))}},"+"))})),Object(s.b)("h2",{id:"extracting-the-pfc"},"Extracting the PFC"),Object(s.b)("p",null,"To make it properly testable, let's first extract all of the JSX into it's own PFC:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-typescript"},'// Counter/UI.tsx => (.TSX) This is important\nimport React from "react";\n\nexport type CounterUIProps = {\n  currentValue: number;\n  increase: () => void;\n  decrease: () => void;\n};\n\nexport const CounterUI = ({\n  currentValue,\n  decrease,\n  increase,\n}: CounterUIProps) => (\n  <div>\n    <button onClick={decrease}>-</button>\n    <span>{currentValue}</span>\n    <button onClick={increase}>+</button>\n  </div>\n);\n')),Object(s.b)("p",null,"Notice how everything the UI needs is functions to ",Object(s.b)("inlineCode",{parentName:"p"},"decrease")," or ",Object(s.b)("inlineCode",{parentName:"p"},"increase")," the counter's ",Object(s.b)("inlineCode",{parentName:"p"},"currentValue"),". It doesn't really matter to the UI if when someone clicks the increment button it gets incremented by one or by a thousand. Or if it's updated at all. It simply cares about rendering based in the props passed down, nothing else. That's React enabling the Single Responsability Principle (aka Separation of Concerns) at it's prime. UI handles display, and that's it. ",Object(s.b)("strong",{parentName:"p"},"Notice how this component has no room for errors apart from the ones that can be caught early at development or later at QA.")," There's absolutely nothing to Unit Test here"),Object(s.b)("h2",{id:"extract-the-controller-hook"},"Extract the Controller Hook"),Object(s.b)("p",null,"If by some reason you happen to think that having to write the ",Object(s.b)("inlineCode",{parentName:"p"},"CounterUIProps")," type alias is cumbersome, notice how neatly it becomes a perfect contract between the component and it's controlling hook:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-typescript"},'// Counter/useCounterController.ts => (.TS) This is important!\nimport { CounterUIProps } from "./CounterUI";\n\nexport const useCounterController = (\n  initialValue = 0,\n  increment = 1\n): CounterUIProps => {\n  const [currentValue, setCurrentValue] = useState(initialValue);\n\n  const increase = () =>\n    setCurrentValue((currentValue) => currentValue + increment);\n\n  const decrease = () =>\n    setCurrentValue((currentValue) => currentValue - increment);\n\n  return {\n    currentValue,\n    increase,\n    decrease,\n  };\n};\n')),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},Object(s.b)("strong",{parentName:"p"},"Please Note"),": The proposed ",Object(s.b)("inlineCode",{parentName:"p"},"use<ComponentName>Controller"),' convention is just that, a proposal. The "Controller" part of it ',Object(s.b)("strong",{parentName:"p"},"IS NOT"),' a silly attempt of reviving the old school MVC pattern. This is a Controller in the sense it\'s what "controls" the behavior of the UI. Of course we can replace ',Object(s.b)("inlineCode",{parentName:"p"},"Controller")," for whatever makes more sense for the team, but I've seen it used in the wild before.")),Object(s.b)("h2",{id:"blundling-it-up"},"Blundling it up"),Object(s.b)("p",null,"Now the ",Object(s.b)("inlineCode",{parentName:"p"},"Counter")," component can be written like this:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-typescript"},'// Counter/index.tsx\nimport React from "react";\n\nimport { useCounterController } from "./useCounterController";\nimport { CounterUI } from "./CounterUI";\n\nconst Counter = () => <CounterUI {...useCounterController()} />;\n\nexport default Counter;\n')),Object(s.b)("p",null,"Yes, it does work. Check this baby out!"),Object(s.b)(i.b,{__position:1,__code:"() => <CounterUI {...useCounterController()} />",__scope:(n={props:d,DefaultLayout:c.a,useState:a.useState,Playground:i.b,CounterUI:l.a,useCounterController:u.a},n.DefaultLayout=c.a,n._frontmatter=b,n),mdxType:"Playground"},(function(){return Object(s.b)(l.a,Object(o.a)({},Object(u.a)(),{mdxType:"CounterUI"}))})),Object(s.b)("p",null,"Hopefully we already agree that the UI should be tested by a person through Storybook, right? Now, do you see how easy it is now to actually test the code that matters for the counter? By doing so, we've just enabled ",Object(s.b)("a",{parentName:"p",href:"/testing/testing-hooks"},"direct testing of the functionality")," we want tested"),Object(s.b)("h2",{id:"reasons-for-splitting-code"},"Reasons for splitting code"),Object(s.b)("p",null,"If you've been paying close attention, you'll notice that I've explicitly told you to watch out for the fact that we are splitting the ",Object(s.b)("em",{parentName:"p"},"CounterUI",Object(s.b)("strong",{parentName:"em"},".tsx"))," and ",Object(s.b)("em",{parentName:"p"},"useCounterController",Object(s.b)("strong",{parentName:"em"},".ts"))," files each into their own separate files. Now notice how that the extensions are different."),Object(s.b)("p",null,"The reason for that is to make dead simple to exclude JSX-only code from the unit testing pipeline. A simple removal of the ",Object(s.b)("inlineCode",{parentName:"p"},"*.tsx")," extension from the jest matching pattern will be enough to ensure the coverage reports only refers to what actually matters."),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},"I'm pretty sure there must be a better way to exclude PFCs from coverage reports. If you know how to do it, your PR is always welcome")))}void 0!==h&&h&&h===Object(h)&&Object.isExtensible(h)&&!h.hasOwnProperty("__filemeta")&&Object.defineProperty(h,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/articles/testing/4-separating-concerns/index.mdx"}}),h.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-articles-testing-4-separating-concerns-index-mdx-0be88c4a41a26865d420.js.map